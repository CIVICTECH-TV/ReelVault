import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { listen } from '@tauri-apps/api/event';

import { 
  TauriCommands, 
  UploadConfig, 
  UploadItem,
  UploadStatus,
  UploadProgress,
  AppConfig,
  AppState,
  AwsCredentials
} from '../services/tauriCommands';
import { debugLog, debugError, debugInfo } from '../utils/debug';
import './UploadManager.css';

// „Ç¢„Ç§„Ç≥„É≥„ÅÆ„Ç§„É≥„Éù„Éº„Éà
import backupIcon from '../assets/icons/backup.svg';

// „Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫„Éï„Ç©„Éº„Éû„ÉÉ„ÉàÈñ¢Êï∞
const formatBytes = (bytes: number): string => {
  if (bytes === 0) return '0 B';
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
};

interface UploadManagerProps {
  config: AppConfig;
  onConfigChange: (path: string, value: any) => void;
  onStateChange: (state: AppState) => void;
  onError: (error: string) => void;
  onSuccess: (message: string) => void;
}

// ÁÑ°ÊñôÁâàÂà∂Èôê
const FREE_TIER_LIMITS = {
  MAX_CONCURRENT_UPLOADS: 1,
  MAX_CONCURRENT_PARTS: 1,
  CHUNK_SIZE_MB: 5,
  RETRY_ATTEMPTS: 3,
  TIMEOUT_SECONDS: 600,
  ENABLE_RESUME: false,
  ADAPTIVE_CHUNK_SIZE: false,
  MIN_CHUNK_SIZE_MB: 5,
  MAX_CHUNK_SIZE_MB: 5
};

// „Éó„É¨„Éü„Ç¢„É†ÁâàÂà∂Èôê
const PREMIUM_TIER_LIMITS = {
  MAX_CONCURRENT_UPLOADS: 8,
  MAX_CONCURRENT_PARTS: 8,
  CHUNK_SIZE_MB: 10,
  RETRY_ATTEMPTS: 10,
  TIMEOUT_SECONDS: 1800,
  ENABLE_RESUME: true,
  ADAPTIVE_CHUNK_SIZE: true,
  MIN_CHUNK_SIZE_MB: 5,
  MAX_CHUNK_SIZE_MB: 1024
};

export const UploadManager: React.FC<UploadManagerProps> = ({
  config,
  onConfigChange,
  onStateChange,
  onError,
  onSuccess
}) => {
  const [isDragOver, _setIsDragOver] = useState(false);
  const [uploadQueue, setUploadQueue] = useState<UploadItem[]>([]);
  const [isUploading, setIsUploading] = useState(false);
  const [uploadConfig, setUploadConfig] = useState<UploadConfig | null>(null);
  const [tempConfig, setTempConfig] = useState<Partial<UploadConfig> | null>(null);
  const [showSettings, setShowSettings] = useState(false);
  const [selectedFiles, setSelectedFiles] = useState<{ selected_files: string[]; total_size: number; file_count: number } | null>(null);
  const [currentTier, setCurrentTier] = useState<'Free' | 'Premium'>('Free');
  
  // „Éá„Éê„ÉÉ„Ç∞Áî®: props„ÅÆÁä∂ÊÖã„Çí„É≠„Ç∞Âá∫Âäõ
  useEffect(() => {
    debugLog('üîç UploadManager propsÁä∂ÊÖã:', {
      awsCredentials: config.aws_settings.default_region ? '„ÅÇ„Çä' : '„Å™„Åó',
      bucketName: config.user_preferences.default_bucket_name || '„Å™„Åó',
      uploadConfig: uploadConfig ? '„ÅÇ„Çä' : '„Å™„Åó'
    });
  }, [config, uploadConfig]);
  
  // „Éç„Ç§„ÉÜ„Ç£„Éñ„Éï„Ç°„Ç§„É´„ÉÄ„Ç§„Ç¢„É≠„Ç∞„Çí‰ΩøÁî®„Åô„Çã„Åü„ÇÅ„ÄÅref„ÅØ‰∏çË¶Å
  const [_forceUpdate, setForceUpdate] = useState(0);

  // ÂàùÊúüÂåñ
  useEffect(() => {
    const initializeUpload = async () => {
      if (!config.user_preferences.default_bucket_name) {
        debugInfo('Bucket name not available');
        return;
      }

      try {
        // üéØ „Éá„Éï„Ç©„É´„Éà„ÅØ„Éó„É¨„Éü„Ç¢„É†ÁâàË®≠ÂÆö
        const defaultConfig = createConfig(config, 'Premium');
        
        // üîç Ë®≠ÂÆöÂÜÖÂÆπ„Çí„Éá„Éê„ÉÉ„Ç∞Âá∫Âäõ
        debugLog('üîß ÁîüÊàê„Åï„Çå„ÅüË®≠ÂÆö:', {
          bucket: defaultConfig.bucket_name,
          tier: defaultConfig.tier,
          maxConcurrent: defaultConfig.max_concurrent_uploads,
          chunkSize: defaultConfig.chunk_size_mb,
          retryAttempts: defaultConfig.retry_attempts
        });

        setUploadConfig(defaultConfig);
        setTempConfig(defaultConfig);
        setCurrentTier(defaultConfig.tier);
      } catch (error) {
        debugError('Upload config initialization failed:', error);
        onError('„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâË®≠ÂÆö„ÅÆÂàùÊúüÂåñ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
      }
    };

    initializeUpload();
  }, [config]);

  // uploadQueue„ÅÆÂ§âÊõ¥„ÇíÁõ£Ë¶ñ„Åó„Å¶Âº∑Âà∂ÁöÑ„Å´ÂÜç„É¨„É≥„ÉÄ„É™„É≥„Ç∞
  useEffect(() => {
    setForceUpdate(prev => prev + 1);
  }, [uploadQueue]);

  // „Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂÆå‰∫ÜÁõ£Ë¶ñ
  useEffect(() => {
    if (!uploadConfig || !isUploading) return;

    const interval = setInterval(async () => {
      try {
        const queueItems = await TauriCommands.getUploadQueueItems();
        setUploadQueue(queueItems);

        // ÂÖ®„Å¶ÂÆå‰∫Ü„Åó„Åü„Åã„ÉÅ„Çß„ÉÉ„ÇØ
        const allCompleted = queueItems.every(item => 
          item.status === UploadStatus.Completed || 
          item.status === UploadStatus.Failed || 
          item.status === UploadStatus.Cancelled
        );

        if (allCompleted && queueItems.length > 0) {
          setIsUploading(false);
          debugInfo('üéâ ÂÖ®„Å¶„ÅÆ„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„ÅüÔºàÂÆöÊúü„ÉÅ„Çß„ÉÉ„ÇØÔºâ');
          const completedItems = queueItems.filter(item => item.status === UploadStatus.Completed);
          onSuccess?.(`${completedItems.length}ÂÄã„ÅÆ„Éï„Ç°„Ç§„É´„Åå„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂÆå‰∫Ü„Åó„Åæ„Åó„Åü`);
        }
      } catch (err) {
        debugError('Upload queue check failed:', err);
        clearInterval(interval);
      }
    }, 1000);

    return () => {
      clearInterval(interval);
    };
  }, [uploadConfig, isUploading, onSuccess]);

  // „Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫„ÅÆÊ§úË®º
  const validateFileSize = (files: File[]): { valid: boolean; message?: string } => {
    const maxSize = 1024 * 1024 * 1024 * 1024; // 1TB
    const oversizedFiles = files.filter(file => file.size > maxSize);
    
    if (oversizedFiles.length > 0) {
      return {
        valid: false,
        message: `${oversizedFiles.length}ÂÄã„ÅÆ„Éï„Ç°„Ç§„É´„Åå1TBÂà∂Èôê„ÇíË∂Ö„Åà„Å¶„ÅÑ„Åæ„Åô`
      };
    }
    
    return { valid: true };
  };

  // üéØ Áµ±‰∏Ä„Åï„Çå„ÅüË®≠ÂÆöÁîüÊàêÈñ¢Êï∞
  const createConfig = (currentConfig: AppConfig, tier: 'Free' | 'Premium'): UploadConfig => {
    const limits = tier === 'Free' ? FREE_TIER_LIMITS : PREMIUM_TIER_LIMITS;
    
    // Ë™çË®ºÊÉÖÂ†±„ÅØÂà•ÈÄîÁÆ°ÁêÜ„Åï„Çå„Å¶„ÅÑ„Çã„Åü„ÇÅ„ÄÅ„Åì„Åì„Åß„ÅØÁ©∫„ÅÆ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíË®≠ÂÆö
    // ÂÆüÈöõ„ÅÆË™çË®ºÊÉÖÂ†±„ÅØTauriCommandsÂÅ¥„ÅßÁÆ°ÁêÜ„Åï„Çå„Çã
    const awsCredentials: AwsCredentials = {
      access_key_id: '', // ÂÆüÈöõ„ÅÆÂÄ§„ÅØTauriCommandsÂÅ¥„ÅßË®≠ÂÆö
      secret_access_key: '',
      region: currentConfig.aws_settings.default_region,
      session_token: undefined
    };
    
    return {
      aws_credentials: awsCredentials,
      bucket_name: currentConfig.user_preferences.default_bucket_name || '',
      tier: tier,
      chunk_size_mb: limits.CHUNK_SIZE_MB,
      max_concurrent_uploads: limits.MAX_CONCURRENT_UPLOADS,
      max_concurrent_parts: limits.MAX_CONCURRENT_PARTS,
      adaptive_chunk_size: limits.ADAPTIVE_CHUNK_SIZE,
      min_chunk_size_mb: limits.MIN_CHUNK_SIZE_MB,
      max_chunk_size_mb: limits.MAX_CHUNK_SIZE_MB,
      retry_attempts: limits.RETRY_ATTEMPTS,
      timeout_seconds: limits.TIMEOUT_SECONDS,
      auto_create_metadata: true,
      s3_key_prefix: 'uploads',
      enable_resume: limits.ENABLE_RESUME,
      bandwidth_limit_mbps: undefined
    };
  };

  const handleTierChange = (tier: 'Free' | 'Premium') => {
    setCurrentTier(tier);
  };

  const applySettings = async () => {
    if (!tempConfig || !config.user_preferences.default_bucket_name) return;
    
    try {
      const newConfig = createConfig(config, currentTier);
      setUploadConfig(newConfig);
      setShowSettings(false);
      onSuccess('Ë®≠ÂÆö„ÇíÈÅ©Áî®„Åó„Åæ„Åó„Åü');
    } catch (error) {
      debugError('Settings application failed:', error);
      onError('Ë®≠ÂÆö„ÅÆÈÅ©Áî®„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
    }
  };

  const handleStartUpload = async () => {
    if (!uploadConfig || !selectedFiles) {
      onError('„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâË®≠ÂÆö„Åæ„Åü„ÅØ„Éï„Ç°„Ç§„É´„ÅåÈÅ∏Êäû„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì');
      return;
    }

    try {
      setIsUploading(true);
      
      // „Åæ„Åö„Ç≠„É•„Éº„ÇíÂàùÊúüÂåñ
      await TauriCommands.initializeUploadQueue(uploadConfig);
      
      // „Éï„Ç°„Ç§„É´„Çí„Ç≠„É•„Éº„Å´ËøΩÂä†
      const s3KeyConfig = {
        prefix: uploadConfig.s3_key_prefix,
        use_date_folder: true,
        preserve_directory_structure: false,
        custom_naming_pattern: undefined
      };
      await TauriCommands.addFilesToUploadQueue(selectedFiles.selected_files, s3KeyConfig);
      
      // „Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂá¶ÁêÜ„ÇíÈñãÂßã
      await TauriCommands.startUploadProcessing();
      
      debugInfo('Upload started successfully');
      onSuccess('„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„ÇíÈñãÂßã„Åó„Åæ„Åó„Åü');
    } catch (error) {
      debugError('Upload start failed:', error);
      onError(error instanceof Error ? error.message : '„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÈñãÂßã„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
      setIsUploading(false);
    }
  };

  const handleFileSelect = async () => {
    try {
      // TauriCommands„Çí‰ΩøÁî®„Åó„Å¶„Éï„Ç°„Ç§„É´ÈÅ∏Êäû
      const result = await TauriCommands.openFileDialog(true, undefined);
      
      if (result && result.file_count > 0) {
        setSelectedFiles({
          selected_files: result.selected_files,
          total_size: result.total_size,
          file_count: result.file_count
        });

        debugInfo('Files selected:', { count: result.file_count, totalSize: result.total_size });
      }
    } catch (error) {
      debugError('File selection failed:', error);
      onError('„Éï„Ç°„Ç§„É´ÈÅ∏Êäû„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
    }
  };

  const handleStopUpload = async () => {
    try {
      await TauriCommands.stopUploadProcessing();
      setIsUploading(false);
      onSuccess('„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„ÇíÂÅúÊ≠¢„Åó„Åæ„Åó„Åü');
    } catch (error) {
      debugError('Upload stop failed:', error);
      onError('„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂÅúÊ≠¢„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
    }
  };

  const handleClearQueue = async () => {
    try {
      await TauriCommands.clearUploadQueue();
      setUploadQueue([]);
      onSuccess('„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Ç≠„É•„Éº„Çí„ÇØ„É™„Ç¢„Åó„Åæ„Åó„Åü');
    } catch (error) {
      debugError('Queue clear failed:', error);
      onError('„Ç≠„É•„Éº„ÇØ„É™„Ç¢„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
    }
  };

  return (
    <div className="upload-manager">
      {/* „É°„Ç§„É≥„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Ç®„É™„Ç¢ */}
      <div className="upload-area">
        <div className="upload-header">
          <h3>üìÅ „Éï„Ç°„Ç§„É´„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ</h3>
          <div className="upload-controls">
            <button onClick={() => setShowSettings(true)} className="btn-secondary">
              ‚öôÔ∏è Ë®≠ÂÆö
            </button>
          </div>
        </div>

        {/* „Éï„Ç°„Ç§„É´ÈÅ∏Êäû„Ç®„É™„Ç¢ */}
        <div className="file-selection-area">
          <button onClick={handleFileSelect} className="btn-primary" disabled={isUploading}>
            üìÇ „Éï„Ç°„Ç§„É´„ÇíÈÅ∏Êäû
          </button>
          
          {selectedFiles && (
            <div className="selected-files">
              <h4>ÈÅ∏Êäû„Åï„Çå„Åü„Éï„Ç°„Ç§„É´ ({selectedFiles.file_count}ÂÄã)</h4>
              <p>ÂêàË®à„Çµ„Ç§„Ç∫: {formatBytes(selectedFiles.total_size)}</p>
              <ul>
                {selectedFiles.selected_files.slice(0, 5).map((file, index) => (
                  <li key={index}>{file}</li>
                ))}
                {selectedFiles.selected_files.length > 5 && (
                  <li>... ‰ªñ {selectedFiles.selected_files.length - 5}ÂÄã</li>
                )}
              </ul>
            </div>
          )}
        </div>

        {/* „Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂà∂Âæ° */}
        {selectedFiles && (
          <div className="upload-controls">
            <button 
              onClick={handleStartUpload} 
              disabled={isUploading || !uploadConfig} 
              className="btn-primary"
            >
              {isUploading ? 'üîÑ „Ç¢„ÉÉ„Éó„É≠„Éº„Éâ‰∏≠...' : 'üöÄ „Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÈñãÂßã'}
            </button>
            
            {isUploading && (
              <button onClick={handleStopUpload} className="btn-secondary">
                ‚èπÔ∏è ÂÅúÊ≠¢
              </button>
            )}
          </div>
        )}

        {/* „Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Ç≠„É•„Éº */}
        {uploadQueue.length > 0 && (
          <div className="upload-queue">
            <h4>„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Ç≠„É•„Éº ({uploadQueue.length}ÂÄã)</h4>
            <div className="queue-controls">
              <button onClick={handleClearQueue} className="btn-secondary">
                üóëÔ∏è „Ç≠„É•„Éº„Çí„ÇØ„É™„Ç¢
              </button>
            </div>
            <div className="queue-items">
              {uploadQueue.map((item) => (
                <div key={item.id} className={`queue-item ${item.status.toLowerCase()}`}>
                  <div className="item-info">
                    <span className="item-name">{item.file_path.split('/').pop()}</span>
                    <span className="item-status">{item.status}</span>
                  </div>
                  {item.status === UploadStatus.InProgress && (
                    <div className="progress-bar">
                      <div 
                        className="progress-fill" 
                        style={{ width: `${item.progress}%` }}
                      ></div>
                    </div>
                  )}
                </div>
              ))}
            </div>
          </div>
        )}
      </div>

      {/* üéØ Ë®≠ÂÆö„Éë„Éç„É´Ôºà„É¢„Éº„ÉÄ„É´Ôºâ */}
      {showSettings && tempConfig && (
        <div className="settings-modal">
          <div className="settings-content">
            <div className="settings-header">
              <h3>‚öôÔ∏è „Ç¢„ÉÉ„Éó„É≠„Éº„ÉâË®≠ÂÆö</h3>
              <button onClick={() => setShowSettings(false)} className="close-btn">√ó</button>
            </div>

            <div className="settings-body">
              {/* Âü∫Êú¨ÊÉÖÂ†± */}
              <div className="settings-section">
                <h4>üìä Âü∫Êú¨ÊÉÖÂ†±</h4>
                <div className="setting-row">
                  <div className="setting-cell" data-label="Ë™çË®ºÊÉÖÂ†±">
                    <input
                      type="text"
                      value={config.aws_settings.default_region ? '„ÅÇ„Çä' : '„Å™„Åó'}
                      disabled
                      className="readonly-input"
                    />
                  </div>
                  <div className="setting-cell" data-label="„Éê„Ç±„ÉÉ„ÉàÂêç">
                    <input
                      type="text"
                      value={config.user_preferences.default_bucket_name || 'Êú™Ë®≠ÂÆö'}
                      disabled
                      className="readonly-input"
                    />
                  </div>
                </div>
              </div>

              {/* Ê©üËÉΩ„ÉÜ„Ç£„Ç¢ÈÅ∏Êäû */}
              <div className="settings-section">
                <h4>üéØ Ê©üËÉΩ„ÉÜ„Ç£„Ç¢</h4>
                <div className="tier-selection">
                  <label className="tier-option">
                    <input
                      type="radio"
                      name="tier"
                      value="Free"
                      checked={currentTier === 'Free'}
                      onChange={(e) => handleTierChange(e.target.value as 'Free' | 'Premium')}
                    />
                    <span className="tier-label">üÜì ÁÑ°ÊñôÁâà</span>
                    <span className="tier-description">
                      1„Éï„Ç°„Ç§„É´„Åö„Å§„ÄÅ5MB„ÉÅ„É£„É≥„ÇØ„ÄÅÂÜçÈñãÊ©üËÉΩ„Å™„Åó
                    </span>
                  </label>
                  
                  <label className="tier-option">
                    <input
                      type="radio"
                      name="tier"
                      value="Premium"
                      checked={currentTier === 'Premium'}
                      onChange={(e) => handleTierChange(e.target.value as 'Free' | 'Premium')}
                    />
                    <span className="tier-label">üíé „Éó„É¨„Éü„Ç¢„É†Áâà</span>
                    <span className="tier-description">
                      8„Éï„Ç°„Ç§„É´ÂêåÊôÇ„ÄÅÂãïÁöÑ„ÉÅ„É£„É≥„ÇØ„ÄÅÂÜçÈñãÊ©üËÉΩ„ÅÇ„Çä
                    </span>
                  </label>
                </div>
              </div>

              {/* Ë©≥Á¥∞Ë®≠ÂÆö */}
              <div className="settings-section">
                <h4>üîß Ë©≥Á¥∞Ë®≠ÂÆö</h4>
                <div className="setting-row">
                  <div className="setting-cell">
                    <label htmlFor="concurrent-uploads-input" className="setting-label-complex">
                      <span>ÂêåÊôÇ„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÊï∞</span>
                      <span className="setting-description-inline">
                        ({currentTier === 'Free' 
                          ? `ÁÑ°ÊñôÁâà: ${FREE_TIER_LIMITS.MAX_CONCURRENT_UPLOADS}ÂÄã„Å´Âõ∫ÂÆö` 
                          : 'Ë®≠ÂÆöÁØÑÂõ≤: 1ÔΩû20ÂÄã'})
                      </span>
                    </label>
                    <input
                      id="concurrent-uploads-input"
                      type="number"
                      min="1"
                      max="20"
                      value={tempConfig.max_concurrent_uploads || 1}
                      disabled={currentTier === 'Free'}
                      onChange={(e) => setTempConfig({
                        ...tempConfig, 
                        max_concurrent_uploads: parseInt(e.target.value)
                      })}
                    />
                  </div>
                  <div className="setting-cell">
                    <label className="setting-label-complex">
                      <span>ÂÜçÈñãÊ©üËÉΩ</span>
                    </label>
                    <div className="toggle-control">
                      <label className="toggle-switch">
                        <input 
                          type="checkbox" 
                          checked={tempConfig.enable_resume || false}
                          onChange={(e) => setTempConfig({
                            ...tempConfig, 
                            enable_resume: e.target.checked
                          })}
                          disabled={currentTier === 'Free'}
                        />
                        <span className="toggle-slider"></span>
                      </label>
                      <span className="toggle-label">{tempConfig.enable_resume ? 'ÊúâÂäπ' : 'ÁÑ°Âäπ'}</span>
                    </div>
                  </div>
                </div>
                <div className="setting-row">
                  <div className="setting-cell">
                    <label htmlFor="chunk-size-input" className="setting-label-complex">
                      <span>„ÉÅ„É£„É≥„ÇØ„Çµ„Ç§„Ç∫</span>
                      <span className="setting-description-inline">
                        ({currentTier === 'Free'
                          ? `ÁÑ°ÊñôÁâà: ${FREE_TIER_LIMITS.CHUNK_SIZE_MB}MB„Å´Âõ∫ÂÆö`
                          : tempConfig.adaptive_chunk_size
                            ? 'ÂãïÁöÑ„ÉÅ„É£„É≥„ÇØ„Çµ„Ç§„Ç∫„ÅåÊúâÂäπ'
                            : 'Ë®≠ÂÆöÁØÑÂõ≤: 5ÔΩû1024MB'})
                      </span>
                    </label>
                    <input
                      id="chunk-size-input"
                      type="number"
                      min="5"
                      max="1024"
                      value={tempConfig.chunk_size_mb || 5}
                      disabled={currentTier === 'Free' || tempConfig.adaptive_chunk_size}
                      onChange={(e) => setTempConfig({
                        ...tempConfig, 
                        chunk_size_mb: parseInt(e.target.value)
                      })}
                    />
                  </div>
                  <div className="setting-cell">
                    <label className="setting-label-complex">
                      <span>ÂãïÁöÑ„ÉÅ„É£„É≥„ÇØ„Çµ„Ç§„Ç∫</span>
                    </label>
                    <div className="toggle-control">
                      <label className="toggle-switch">
                        <input 
                          type="checkbox" 
                          checked={tempConfig.adaptive_chunk_size || false}
                          onChange={(e) => setTempConfig({
                            ...tempConfig, 
                            adaptive_chunk_size: e.target.checked
                          })}
                          disabled={currentTier === 'Free'}
                        />
                        <span className="toggle-slider"></span>
                      </label>
                      <span className="toggle-label">{tempConfig.adaptive_chunk_size ? 'ÊúâÂäπ' : 'ÁÑ°Âäπ'}</span>
                    </div>
                  </div>
                </div>
                <div className="slider-setting">
                  <label className="setting-label-complex">
                    <span>ÂÜçË©¶Ë°åÂõûÊï∞</span>
                    <span className="setting-description-inline">
                      („Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂ§±ÊïóÊôÇ„ÅÆÂÜçË©¶Ë°åÂõûÊï∞„ÇíË®≠ÂÆö„Åó„Åæ„Åô)
                    </span>
                  </label>
                  <div className="slider-container">
                    <input
                      type="range"
                      min="1" 
                      max="20"
                      value={tempConfig.retry_attempts || 3}
                      onChange={(e) => setTempConfig({
                        ...tempConfig, 
                        retry_attempts: parseInt(e.target.value)
                      })}
                    />
                    <span className="setting-value">{tempConfig.retry_attempts || 3}Âõû</span>
                  </div>
                </div>
              </div>

              <div className="settings-footer">
                <button onClick={applySettings} className="btn-primary">
                  ‚úÖ Ë®≠ÂÆö„ÇíÈÅ©Áî®
                </button>
                <button onClick={() => setShowSettings(false)} className="btn-secondary">
                  ‚ùå „Ç≠„É£„É≥„Çª„É´
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}; 