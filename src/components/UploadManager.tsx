import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { listen } from '@tauri-apps/api/event';

import { 
  TauriCommands, 
  UploadConfig, 
  UploadItem,
  UploadStatus,
  UploadProgress,
  AppConfig,
  AppState,
  AwsCredentials
} from '../services/tauriCommands';
import { debugLog, debugError, debugInfo } from '../utils/debug';
// import './UploadManager.css'; // ÂâäÈô§

// „Ç¢„Ç§„Ç≥„É≥„ÅÆ„Ç§„É≥„Éù„Éº„Éà
import backupIcon from '../assets/icons/backup.svg';

// „Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫„Éï„Ç©„Éº„Éû„ÉÉ„ÉàÈñ¢Êï∞
const formatBytes = (bytes: number): string => {
  if (bytes === 0) return '0 B';
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
};

interface UploadManagerProps {
  config: AppConfig;
  onConfigChange: (path: string, value: any) => void;
  onStateChange: (state: AppState) => void;
  onError: (error: string) => void;
  onSuccess: (message: string) => void;
}

// ÁÑ°ÊñôÁâàÂà∂Èôê
const FREE_TIER_LIMITS = {
  MAX_CONCURRENT_UPLOADS: 1,
  MAX_CONCURRENT_PARTS: 1,
  CHUNK_SIZE_MB: 5,
  RETRY_ATTEMPTS: 3,
  TIMEOUT_SECONDS: 600,
  ENABLE_RESUME: false,
  ADAPTIVE_CHUNK_SIZE: false,
  MIN_CHUNK_SIZE_MB: 5,
  MAX_CHUNK_SIZE_MB: 5
};

// „Éó„É¨„Éü„Ç¢„É†ÁâàÂà∂Èôê
const PREMIUM_TIER_LIMITS = {
  MAX_CONCURRENT_UPLOADS: 8,
  MAX_CONCURRENT_PARTS: 8,
  CHUNK_SIZE_MB: 10,
  RETRY_ATTEMPTS: 10,
  TIMEOUT_SECONDS: 1800,
  ENABLE_RESUME: true,
  ADAPTIVE_CHUNK_SIZE: true,
  MIN_CHUNK_SIZE_MB: 5,
  MAX_CHUNK_SIZE_MB: 1024
};

export const UploadManager: React.FC<UploadManagerProps> = ({
  config,
  onConfigChange,
  onStateChange,
  onError,
  onSuccess
}) => {
  const [isDragOver, _setIsDragOver] = useState(false);
  const [uploadQueue, setUploadQueue] = useState<UploadItem[]>([]);
  const [isUploading, setIsUploading] = useState(false);
  const [uploadConfig, setUploadConfig] = useState<UploadConfig | null>(null);
  const [tempConfig, setTempConfig] = useState<Partial<UploadConfig> | null>(null);
  const [showSettings, setShowSettings] = useState(false);
  const [selectedFiles, setSelectedFiles] = useState<{ selected_files: string[]; total_size: number; file_count: number } | null>(null);
  const [currentTier, setCurrentTier] = useState<'Free' | 'Premium'>('Free');
  
  // „Éá„Éê„ÉÉ„Ç∞Áî®: props„ÅÆÁä∂ÊÖã„Çí„É≠„Ç∞Âá∫Âäõ
  useEffect(() => {
    debugLog('üîç UploadManager propsÁä∂ÊÖã:', {
      awsCredentials: config.aws_settings.default_region ? '„ÅÇ„Çä' : '„Å™„Åó',
      bucketName: config.user_preferences.default_bucket_name || '„Å™„Åó',
      uploadConfig: uploadConfig ? '„ÅÇ„Çä' : '„Å™„Åó'
    });
  }, [config, uploadConfig]);
  
  // „Éç„Ç§„ÉÜ„Ç£„Éñ„Éï„Ç°„Ç§„É´„ÉÄ„Ç§„Ç¢„É≠„Ç∞„Çí‰ΩøÁî®„Åô„Çã„Åü„ÇÅ„ÄÅref„ÅØ‰∏çË¶Å
  const [_forceUpdate, setForceUpdate] = useState(0);

  // ÂàùÊúüÂåñ
  useEffect(() => {
    const initializeUpload = async () => {
      if (!config.user_preferences.default_bucket_name) {
        debugInfo('Bucket name not available');
        return;
      }

      try {
        // üéØ „Éá„Éï„Ç©„É´„Éà„ÅØ„Éó„É¨„Éü„Ç¢„É†ÁâàË®≠ÂÆö
        const defaultConfig = createConfig(config, 'Premium');
        
        // üîç Ë®≠ÂÆöÂÜÖÂÆπ„Çí„Éá„Éê„ÉÉ„Ç∞Âá∫Âäõ
        debugLog('üîß ÁîüÊàê„Åï„Çå„ÅüË®≠ÂÆö:', {
          bucket: defaultConfig.bucket_name,
          tier: defaultConfig.tier,
          maxConcurrent: defaultConfig.max_concurrent_uploads,
          chunkSize: defaultConfig.chunk_size_mb,
          retryAttempts: defaultConfig.retry_attempts
        });

        setUploadConfig(defaultConfig);
        setTempConfig(defaultConfig);
        setCurrentTier(defaultConfig.tier);
      } catch (error) {
        debugError('Upload config initialization failed:', error);
        onError('„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâË®≠ÂÆö„ÅÆÂàùÊúüÂåñ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
      }
    };

    initializeUpload();
  }, [config]);

  // uploadQueue„ÅÆÂ§âÊõ¥„ÇíÁõ£Ë¶ñ„Åó„Å¶Âº∑Âà∂ÁöÑ„Å´ÂÜç„É¨„É≥„ÉÄ„É™„É≥„Ç∞
  useEffect(() => {
    setForceUpdate(prev => prev + 1);
  }, [uploadQueue]);

  // „Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂÆå‰∫ÜÁõ£Ë¶ñ
  useEffect(() => {
    if (!uploadConfig || !isUploading) return;

    const interval = setInterval(async () => {
      try {
        const queueItems = await TauriCommands.getUploadQueueItems();
        setUploadQueue(queueItems);

        // ÂÖ®„Å¶ÂÆå‰∫Ü„Åó„Åü„Åã„ÉÅ„Çß„ÉÉ„ÇØ
        const allCompleted = queueItems.every(item => 
          item.status === UploadStatus.Completed || 
          item.status === UploadStatus.Failed || 
          item.status === UploadStatus.Cancelled
        );

        if (allCompleted && queueItems.length > 0) {
          setIsUploading(false);
          debugInfo('üéâ ÂÖ®„Å¶„ÅÆ„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„ÅüÔºàÂÆöÊúü„ÉÅ„Çß„ÉÉ„ÇØÔºâ');
          const completedItems = queueItems.filter(item => item.status === UploadStatus.Completed);
          onSuccess?.(`${completedItems.length}ÂÄã„ÅÆ„Éï„Ç°„Ç§„É´„Åå„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂÆå‰∫Ü„Åó„Åæ„Åó„Åü`);
        }
      } catch (err) {
        debugError('Upload queue check failed:', err);
        clearInterval(interval);
      }
    }, 1000);

    return () => {
      clearInterval(interval);
    };
  }, [uploadConfig, isUploading, onSuccess]);

  // „Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫„ÅÆÊ§úË®º
  const validateFileSize = (files: File[]): { valid: boolean; message?: string } => {
    const maxSize = 1024 * 1024 * 1024 * 1024; // 1TB
    const oversizedFiles = files.filter(file => file.size > maxSize);
    
    if (oversizedFiles.length > 0) {
      return {
        valid: false,
        message: `${oversizedFiles.length}ÂÄã„ÅÆ„Éï„Ç°„Ç§„É´„Åå1TBÂà∂Èôê„ÇíË∂Ö„Åà„Å¶„ÅÑ„Åæ„Åô`
      };
    }
    
    return { valid: true };
  };

  // üéØ Áµ±‰∏Ä„Åï„Çå„ÅüË®≠ÂÆöÁîüÊàêÈñ¢Êï∞
  const createConfig = (currentConfig: AppConfig, tier: 'Free' | 'Premium'): UploadConfig => {
    const limits = tier === 'Free' ? FREE_TIER_LIMITS : PREMIUM_TIER_LIMITS;
    
    // Ë™çË®ºÊÉÖÂ†±„ÅØÂà•ÈÄîÁÆ°ÁêÜ„Åï„Çå„Å¶„ÅÑ„Çã„Åü„ÇÅ„ÄÅ„Åì„Åì„Åß„ÅØÁ©∫„ÅÆ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíË®≠ÂÆö
    // ÂÆüÈöõ„ÅÆË™çË®ºÊÉÖÂ†±„ÅØTauriCommandsÂÅ¥„ÅßÁÆ°ÁêÜ„Åï„Çå„Çã
    const awsCredentials: AwsCredentials = {
      access_key_id: '', // ÂÆüÈöõ„ÅÆÂÄ§„ÅØTauriCommandsÂÅ¥„ÅßË®≠ÂÆö
      secret_access_key: '',
      region: currentConfig.aws_settings.default_region,
      session_token: undefined
    };
    
    return {
      aws_credentials: awsCredentials,
      bucket_name: currentConfig.user_preferences.default_bucket_name || '',
      tier: tier,
      chunk_size_mb: limits.CHUNK_SIZE_MB,
      max_concurrent_uploads: limits.MAX_CONCURRENT_UPLOADS,
      max_concurrent_parts: limits.MAX_CONCURRENT_PARTS,
      adaptive_chunk_size: limits.ADAPTIVE_CHUNK_SIZE,
      min_chunk_size_mb: limits.MIN_CHUNK_SIZE_MB,
      max_chunk_size_mb: limits.MAX_CHUNK_SIZE_MB,
      retry_attempts: limits.RETRY_ATTEMPTS,
      timeout_seconds: limits.TIMEOUT_SECONDS,
      auto_create_metadata: true,
      s3_key_prefix: 'uploads',
      enable_resume: limits.ENABLE_RESUME,
      bandwidth_limit_mbps: undefined
    };
  };

  const handleTierChange = (tier: 'Free' | 'Premium') => {
    const newConfig = createConfig(config, tier);
    setTempConfig(newConfig);
    setCurrentTier(tier);
  };

  const applySettings = async () => {
    if (!tempConfig) return;
    try {
      await TauriCommands.updateConfig({ upload: tempConfig as UploadConfig });
      setUploadConfig(tempConfig as UploadConfig);
      setShowSettings(false);
      onSuccess('Ë®≠ÂÆö„ÇíÊõ¥Êñ∞„Åó„Åæ„Åó„Åü');
    } catch (error) {
      onError('Ë®≠ÂÆö„ÅÆÈÅ©Áî®„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
    }
  };

  const handleStartUpload = async () => {
    if (!uploadConfig || !selectedFiles) {
      onError('„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâË®≠ÂÆö„Åæ„Åü„ÅØ„Éï„Ç°„Ç§„É´„ÅåÈÅ∏Êäû„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì');
      return;
    }

    try {
      setIsUploading(true);
      
      // „Åæ„Åö„Ç≠„É•„Éº„ÇíÂàùÊúüÂåñ
      await TauriCommands.initializeUploadQueue(uploadConfig);
      
      // „Éï„Ç°„Ç§„É´„Çí„Ç≠„É•„Éº„Å´ËøΩÂä†
      const s3KeyConfig = {
        prefix: uploadConfig.s3_key_prefix,
        use_date_folder: true,
        preserve_directory_structure: false,
        custom_naming_pattern: undefined
      };
      await TauriCommands.addFilesToUploadQueue(selectedFiles.selected_files, s3KeyConfig);
      
      // „Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂá¶ÁêÜ„ÇíÈñãÂßã
      await TauriCommands.startUploadProcessing();
      
      debugInfo('Upload started successfully');
      onSuccess('„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„ÇíÈñãÂßã„Åó„Åæ„Åó„Åü');
    } catch (error) {
      debugError('Upload start failed:', error);
      onError(error instanceof Error ? error.message : '„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÈñãÂßã„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
      setIsUploading(false);
    }
  };

  const handleFileSelect = async () => {
    try {
      const result = await TauriCommands.openFileDialog(true);
      if (result && result.file_count > 0) setSelectedFiles(result);
    } catch (error) {
      onError('„Éï„Ç°„Ç§„É´ÈÅ∏Êäû„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
    }
  };

  const handleStopUpload = async () => {
    try {
      await TauriCommands.stopUploadProcessing();
      setIsUploading(false);
      onSuccess('„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„ÇíÂÅúÊ≠¢„Åó„Åæ„Åó„Åü');
    } catch (error) {
      debugError('Upload stop failed:', error);
      onError('„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂÅúÊ≠¢„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
    }
  };

  const handleClearQueue = async () => {
    try {
      await TauriCommands.clearUploadQueue();
      setUploadQueue([]);
      onSuccess('„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Ç≠„É•„Éº„Çí„ÇØ„É™„Ç¢„Åó„Åæ„Åó„Åü');
    } catch (error) {
      debugError('Queue clear failed:', error);
      onError('„Ç≠„É•„Éº„ÇØ„É™„Ç¢„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
    }
  };

  return (
    <div className="content-container">
      <div className="section-header">
        <h3 className="section-title">
          <span className="icon">
            <img src={backupIcon} alt="Backup Icon" />
          </span>
          „Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó
        </h3>
        <div className="section-header-controls">
          <button onClick={() => setShowSettings(true)} className="btn-secondary">
            ‚öôÔ∏è Ë®≠ÂÆö
          </button>
        </div>
      </div>

      {/* „Éï„Ç°„Ç§„É´ÈÅ∏Êäû„Ç®„É™„Ç¢„Å®Âà∂Âæ° */}
      <div className="section">
        {selectedFiles ? (
          <div className="selected-files-info">
            <h4 className="section-title">ÈÅ∏Êäû„Åï„Çå„Åü„Éï„Ç°„Ç§„É´</h4>
            <div className="file-stats">
              <span><strong>„Éï„Ç°„Ç§„É´Êï∞:</strong> {selectedFiles.file_count}</span>
              <span><strong>ÂêàË®à„Çµ„Ç§„Ç∫:</strong> {formatBytes(selectedFiles.total_size)}</span>
            </div>
            <ul>
              {selectedFiles.selected_files.slice(0, 5).map((file, index) => (
                <li key={index}>{file.split(/[/\\]/).pop()}</li>
              ))}
              {selectedFiles.selected_files.length > 5 && (
                <li>... ‰ªñ {selectedFiles.selected_files.length - 5}ÂÄã</li>
              )}
            </ul>
          </div>
        ) : (
          <div 
            className={`upload-drop-zone`}
            onClick={handleFileSelect}
          >
            <div className="drop-zone-content">
              <div className="upload-icon">üì§</div>
              <div className="drop-zone-text">
                <p>„Åì„Åì„Å´„Éï„Ç°„Ç§„É´„Çí„Éâ„É©„ÉÉ„Ç∞ÔºÜ„Éâ„É≠„ÉÉ„Éó</p>
                <p className="drop-zone-subtext">„Åæ„Åü„ÅØ„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶„Éï„Ç°„Ç§„É´„ÇíÈÅ∏Êäû</p>
              </div>
            </div>
          </div>
        )}

        <div className="control-buttons">
          <button 
            onClick={handleStartUpload} 
            disabled={isUploading || !uploadConfig || !selectedFiles} 
            className="btn-primary"
          >
            {isUploading ? 'üîÑ „Ç¢„ÉÉ„Éó„É≠„Éº„Éâ‰∏≠...' : 'üöÄ „Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÈñãÂßã'}
          </button>
          
          {isUploading && (
            <button onClick={handleStopUpload} className="btn-secondary">
              ‚èπÔ∏è ÂÅúÊ≠¢
            </button>
          )}
          <button onClick={() => setSelectedFiles(null)} className="btn-secondary" disabled={!selectedFiles || isUploading}>
            „ÇØ„É™„Ç¢
          </button>
        </div>
      </div>

      {/* „Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Ç≠„É•„Éº */}
      {uploadQueue.length > 0 && (
        <div className="section">
          <h4 className="section-title">„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Ç≠„É•„Éº ({uploadQueue.length}ÂÄã)</h4>
          <div className="control-buttons">
            <button onClick={handleClearQueue} className="btn-secondary">
              üóëÔ∏è „Ç≠„É•„Éº„Çí„ÇØ„É™„Ç¢
            </button>
          </div>
          <div className="upload-queue-container">
            <div className="queue-items">
              {uploadQueue.map((item) => (
                <div key={item.id} className={`queue-item status-${item.status.toLowerCase()}`}>
                  <div className="item-info">
                    <span className="item-name">{item.file_path.split(/[/\\]/).pop()}</span>
                    <span className="item-details">{formatBytes(item.file_size)}</span>
                  </div>
                  <div className="item-progress">
                    <div className="progress-text">
                      {item.status}: {item.progress.toFixed(1)}%
                    </div>
                    <div className="progress-bar">
                      <div 
                        className="progress-fill"
                        style={{ width: `${item.progress}%` }}
                      />
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </div>
        </div>
      )}

      {/* Ë®≠ÂÆö„Éë„Éç„É´Ôºà„É¢„Éº„ÉÄ„É´Ôºâ */}
      {showSettings && tempConfig && (
        <div className="modal-overlay">
          <div className="modal-content">
            <div className="modal-header">
              <h3><span className="icon">‚öôÔ∏è</span>„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâË®≠ÂÆö</h3>
              <button onClick={() => setShowSettings(false)} className="close-btn">√ó</button>
            </div>
            <div className="modal-body">
              {/* Âü∫Êú¨ÊÉÖÂ†± */}
              <div className="config-group">
                <label>üìä Âü∫Êú¨ÊÉÖÂ†±</label>
                <div className="setting-row">
                  <div className="setting-cell">
                    <label className="setting-label-complex"><span>Ë™çË®ºÊÉÖÂ†±</span></label>
                    <input type="text" value={config.aws_settings.default_region ? '„ÅÇ„Çä' : '„Å™„Åó'} disabled className="readonly-input" />
                  </div>
                  <div className="setting-cell">
                    <label className="setting-label-complex"><span>„Éê„Ç±„ÉÉ„ÉàÂêç</span></label>
                    <input type="text" value={config.user_preferences.default_bucket_name || 'Êú™Ë®≠ÂÆö'} disabled className="readonly-input" />
                  </div>
                </div>
              </div>

              {/* Ê©üËÉΩ„ÉÜ„Ç£„Ç¢ÈÅ∏Êäû */}
              <div className="config-group">
                <label>üéØ Ê©üËÉΩ„ÉÜ„Ç£„Ç¢</label>
                <div className="tier-selection">
                  <label className="tier-option">
                    <input type="radio" name="tier" value="Free" checked={currentTier === 'Free'} onChange={(e) => handleTierChange(e.target.value as 'Free' | 'Premium')} />
                    <span className="tier-label">üÜì ÁÑ°ÊñôÁâà</span>
                    <span className="tier-description">1„Éï„Ç°„Ç§„É´„Åö„Å§„ÄÅ5MB„ÉÅ„É£„É≥„ÇØ„ÄÅÂÜçÈñãÊ©üËÉΩ„Å™„Åó</span>
                  </label>
                  <label className="tier-option">
                    <input type="radio" name="tier" value="Premium" checked={currentTier === 'Premium'} onChange={(e) => handleTierChange(e.target.value as 'Free' | 'Premium')} />
                    <span className="tier-label">üíé „Éó„É¨„Éü„Ç¢„É†Áâà</span>
                    <span className="tier-description">8„Éï„Ç°„Ç§„É´ÂêåÊôÇ„ÄÅÂãïÁöÑ„ÉÅ„É£„É≥„ÇØ„ÄÅÂÜçÈñãÊ©üËÉΩ„ÅÇ„Çä</span>
                  </label>
                </div>
              </div>

              {/* Ë©≥Á¥∞Ë®≠ÂÆö */}
              <div className="config-group">
                <label>üîß Ë©≥Á¥∞Ë®≠ÂÆö</label>
                <div className="setting-row">
                  <div className="setting-cell">
                    <label className="setting-label-complex">
                      <span>ÂêåÊôÇ„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÊï∞</span>
                      <span className="setting-description-inline">({currentTier === 'Free' ? `ÁÑ°ÊñôÁâà: ${FREE_TIER_LIMITS.MAX_CONCURRENT_UPLOADS}ÂÄã` : '1ÔΩû20ÂÄã'})</span>
                    </label>
                    <input type="number" value={tempConfig.max_concurrent_uploads} disabled={currentTier === 'Free'} onChange={e => setTempConfig({...tempConfig, max_concurrent_uploads: parseInt(e.target.value)})} />
                  </div>
                  <div className="setting-cell">
                    <label className="setting-label-complex"><span>ÂÜçÈñãÊ©üËÉΩ</span></label>
                    <div className="toggle-control">
                      <label className="toggle-switch">
                        <input type="checkbox" checked={tempConfig.enable_resume} disabled={currentTier === 'Free'} onChange={e => setTempConfig({...tempConfig, enable_resume: e.target.checked})} />
                        <span className="toggle-slider"></span>
                      </label>
                      <span className="toggle-label">{tempConfig.enable_resume ? 'ÊúâÂäπ' : 'ÁÑ°Âäπ'}</span>
                    </div>
                  </div>
                </div>
                <div className="setting-row">
                  <div className="setting-cell">
                    <label className="setting-label-complex">
                      <span>„ÉÅ„É£„É≥„ÇØ„Çµ„Ç§„Ç∫ (MB)</span>
                      <span className="setting-description-inline">({currentTier === 'Free' ? `${FREE_TIER_LIMITS.CHUNK_SIZE_MB}MB` : '5ÔΩû1024MB'})</span>
                    </label>
                    <input type="number" value={tempConfig.chunk_size_mb} disabled={currentTier === 'Free' || tempConfig.adaptive_chunk_size} onChange={e => setTempConfig({...tempConfig, chunk_size_mb: parseInt(e.target.value)})} />
                  </div>
                   <div className="setting-cell">
                    <label className="setting-label-complex"><span>ÂãïÁöÑ„ÉÅ„É£„É≥„ÇØ</span></label>
                    <div className="toggle-control">
                      <label className="toggle-switch">
                        <input type="checkbox" checked={tempConfig.adaptive_chunk_size} disabled={currentTier === 'Free'} onChange={e => setTempConfig({...tempConfig, adaptive_chunk_size: e.target.checked})} />
                        <span className="toggle-slider"></span>
                      </label>
                       <span className="toggle-label">{tempConfig.adaptive_chunk_size ? 'ÊúâÂäπ' : 'ÁÑ°Âäπ'}</span>
                    </div>
                  </div>
                </div>
                <div className="slider-setting">
                  <label className="setting-label-complex">
                    <span>ÂÜçË©¶Ë°åÂõûÊï∞</span>
                    <span className="setting-description-inline">(Â§±ÊïóÊôÇ„ÅÆ„É™„Éà„É©„Ç§ÂõûÊï∞)</span>
                  </label>
                  <div className="slider-container">
                    <input type="range" min="1" max="20" value={tempConfig.retry_attempts} onChange={e => setTempConfig({...tempConfig, retry_attempts: parseInt(e.target.value)})} />
                    <span className="setting-value">{tempConfig.retry_attempts}Âõû</span>
                  </div>
                </div>
              </div>
            </div>
            <div className="modal-footer">
              <button onClick={() => setShowSettings(false)} className="btn-secondary">„Ç≠„É£„É≥„Çª„É´</button>
              <button onClick={applySettings} className="btn-primary">‚úÖ Ë®≠ÂÆö„ÇíÈÅ©Áî®</button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}; 